# 사용 추적 시스템 

## 질문 

- alloc, free, realloc, calloc simple 
- new, delete, new[], delete[]
- stl allocator 

위의 것들로 충분한가? 그래 보인다. 
WISE_NEW, WISE_DELETE, WiSE_ALLOC, WISE_FREE, WISE_REALLOC, WISE_CALLOC, 

매크로. 위 외에는 사용하지 않도록 함으로써 처리 가능. 
shared_ptr은 어떻게 하는가? 

위와 같이 추적하는 것보다는 추적이 필요한 오브젝트를 정하고 관리하는 게 나을 수도 있다. 

mem_tracked, mem_tracker 

```c++
class object : public mem_tracked 
{
}

설명을 넣고, 추적을 자동화한다. 
자료의 rmem과 유사한 방법을 활용할 수 있다. 

여러 기법들을 모아서 정리한다. 정리 과정은 단위 테스트로 진행한다. 


### shared_ptr의 메모리 트래킹


## 자료 

- http://www.almostinfinite.com/memtrack.html
  - 오래된 고전적인 기법들에 대한 것 

- https://github.com/milostosic/MTuner
  - 멋진 프로파일링 화면을 갖고 있다. 
  - rmem 라이브러리를 갖고 있다. 

  rmem 라이브러리는 트래킹 전용이다. 

  - 아래와 같이 활동을 기록한다.  
  ```c++
  rmemRealloc(0, ptr, (uint32_t)_size, (uint32_t)getReallocOverhead(ptr), _ptr);
  ```

  - 아래와 같이 설명을 추가한다. 
  ```c++
  RMEM_REGISTER_TAG("Root tag");
	RMEM_REGISTER_TAG_CHILD("First half - Alloc", "Root tag");
	RMEM_REGISTER_TAG_CHILD("First half - Realloc", "Root tag");
	RMEM_REGISTER_TAG_CHILD("Second half", "Root tag");
  ```

  간결한 핵심 아이디어와 깔끔한 UI는 제품의 성공 비결이다. rmem이 그러하다. 


 - bazel 
   - build system 
   - 항상 새로운 것들이 나타낸다. 
   - 






